# Database

**Реляционная модель**

- Реляционная модель представляет собой фиксированную структуру математических понятий, которая описывает, как будут представлены данные;
- Базовой единицей данных в пределах реляционной модели является таблица;
- Таблица — это базовая единица данных. В реляционной алгебре она называется «отношение» (relation). Состоит из атрибутов (columns), которые определяют конкретные типы данных. Данные в таблице организованы в кортежи (rows), которые содержат множества значений столбцов.

**Преимущества:**
- Эффективное поддержание целостности данных;
- Блокировка и очередность доступа к данным;
- Атомарность данных (возможность использования сложных типов данных);
- Поддержка процедурных языков;
- Независимость физической и логической моделей.

Реляционная модель данных — созданная Эдгаром Коддом логическая модель данных, описывающая:
- структуры данных в виде наборов отношений;
- теоретико-множественные операции над данными: объединение, пересечение разность и декартово произведение;
- специальные реляционные операции: селекция, проекция, соединение и деление;
- специальные правила, обеспечивающие целостность данных.

**Ограничения**

**Первичные ключи** - При создании таблицы могут быть использованы различные «ограничения» (CONSTRAINTS), которые содержат правила, указывающие, какие данные представлены в ней. Одним из самых используемых ограничений является первичный ключ (PRIMARY KEY), который гарантирует, что каждая строка таблицы содержит уникальный идентификатор. Правильным считается наличие первичного ключа во всех таблицах базы данных. PRIMARY KEY = UNIQUE + NOT NULL + INDEX

Первичный ключ может состоять из одного или нескольких столбцов. Первичные ключи, состоящие из нескольких столбцов называются «составными» (COMPOSITE).

**Натуральные первичные ключи** - Представляют собой данные, которые уже присутствуют в описываемой предметной области. Например, почтовые индексы могут быть использованы как естественные первичные ключи без дополнительной обработки. Их использование, если оно возможно, считается более правильным, чем искусственных. В справочнике стран натуральным первичным ключом может быть ISO код стран. В справочнике граждан РФ натуральным составным первичным ключом может быть серия и номер паспорта.

**Суррогатные первичные ключи** - Представляют собой целочисленный идентификатор. Применяется там, где нет возможности использовать натуральный первичный ключ. Позволяют решать те же практические задачи, что и естественные: улучшение производительности памяти и индексов при операциях обновления.

**Внешние ключи** - В то время как одна таблица имеет первичный ключ, другая таблица может иметь ограничение, описывающее, что её значения ссылаются на гарантированно существующие значения в первой таблице. Это реализуется через создание в «дочерней» таблице столбца (может быть несколько столбцов), значениями которого являются значения первичного ключа из «родительской» таблицы.

Вместе наборы этих столбцов составляют внешний ключ (FOREIGN KEY), который является механизмом базы данных, гарантирующим, что значения в «дочерних» столбцах присутствуют как первичные ключи в «родительских».
Это ограничение контролирует все операции на этих таблицах:
- добавление / изменение данных в «дочерней» таблице
- удаление / изменение данных в «родительской» таблице.
Внешний ключ проверяет, чтобы данные корректно присутствовали в обеих таблицах. Иначе операции будут отменены.

Внешние ключи могут быть составными. Как правило «родителем» во внешнем ключе является первичный ключ, но при необходимости «родителем» может быть любой столбец, который имеет ограничение уникальности (UNIQUE).

**UNIQUE**

Ограничение UNIQUE:
- гарантирует, что все значения в столбце будут уникальными.
- может быть наложено на один или несколько столбцов.
В каждой таблице может быть несколько уникальных ограничений. Ограничение первичного ключа имеет ограничение UNIQUE по умолчанию.

**NOT NULL**

Изначально столбец в таблице может содержать любые значения, включая «нулевые» значения, то есть пустые значения. Ограничение NOT NULL делает так, что в столбец нельзя записать «нулевые» значения. Таким образом, поле всегда будет содержать значение и при попытке внести пустое значение при добавлении или изменении записи будет выбрасывать ошибку. Ограничение первичного ключа имеет ограничение NOT NULL по умолчанию.

**CHECK**

Ограничение CHECK:
- используется для ограничения диапазона значений, который может быть записан в столбец.
- может быть указано для одного столбца и допускает только определенные значения для этого столбца.
- может быть указано для таблицы, таким образом оно ограничивает значения в определенных столбцах на основе значений в других столбцах строки.

**Нормализация**

**Нормализация** — это метод проектирования базы данных, который используется для разработки таблицы реляционной базы данных до более высокой нормальной формы. При этом данный процесс является прогрессивным, и более высокий уровень нормализации базы данных не может быть достигнут, если не были выполнены предыдущие уровни.

**1 нормальная форма**

Чтобы таблица удовлетворяла 1НФ, значения в каждом столбце должны быть атомарными. То есть, значения в домене каждого атрибута отношения не являются ни списками, ни множествами простых или сложных значений.

**2 нормальная форма**

Таблица обязана соответствовать первой нормальной форме. Все столбцы, которые не являются частью ключа, зависят от этого ключа. Чтобы соответствовать 2НФ и удалить дубликаты, каждый неключевой атрибут должен зависеть от всего ключа, а не только от его части.

**3 нормальная форма**

Таблица обязана соответствовать второй нормальной форме. Значения, входящие в запись и не являющиеся частью ключа этой записи, не принадлежат таблице. 

**Нормальная Форма Бойса-Кодда**

Реляционная схема считается в нормальной форме Бойса-Кодда (НФБК), если для каждой из ее зависимостей A → B выполняется одно из следующих условий:
- A → B является тривиальной функциональной зависимостью (то есть B является подмножеством A);
- A — первичный ключ для схемы реляционной схемы.
То есть, если таблица находится в 3НФ и все ее столбцы являются частью составного первичного ключа, то эта таблица находится в НФБК. НФБК — это расширенная 3НФ. Как правило 3НФ является желаемым результатом и дальнейшая нормализация может приводить к ненужному результату, из-за которого усложняется выборка данных.

**4 нормальная форма**

4 нормальная форма применяется для устранения многозначных зависимостей — таких зависимостей, где столбец с первичным ключом имеет связь один-ко-многим со столбцом, который не является ключом. Эта нормальная форма устраняет некорректные отношения многие-ко-многим.

**5 нормальная форма**

5 нормальная форма разделяет таблицы на более малые таблицы для устранения избыточности данных. Разбиение идет до тех пор, пока нельзя будет воссоздать оригинальную таблицу путем объединения малых таблиц

**Нормализация**

При проектировании базы можно избегать какие-либо формы нормализации. Если изначально есть понимание разделения сущностей и связей по своим местам, то можно пропустить начальные формы нормализации. Также при исправлении нарушений одной нормальной формы можно заранее учесть нарушения более высокой формы. Рассматривать ETNF (основного домена), DKNF (ключа домена), 6 нормальную форму не будем, так как они носят больше научный характер и на практике не применяются.

**Функциональные зависимости**

Функциональные зависимости — это основа нормализации баз данных. Под функциональной зависимостью подразумевается зависимость значения одного атрибута от другого. Если даны два атрибута А и Б некоторого отношения, то говорят, что Б функционально зависит от А, если в любой момент времени каждому значению А соответствует ровно одно значение Б.

**Денормализация**

Денормализация — это процесс ухода от правил нормализации там, где это необходимо. Для процесса денормализации не существует стандартного алгоритма. Процесс денормализации индивидуален и требует четкого понимания, для чего он необходим в связи с появлением избыточности.

К денормализации прибегают для сокращения времени обработки запросов и уменьшения затрат ресурсов. В нормализованных базах часто приходится соединять большое количество таблиц или добавлять агрегацию. Таким образом денормализацию можно выполнить сократив количество таблиц или добавив новые столбцы в существующую таблицу. При этом учитывая избыточность данных необходимо следить за целостностью данных. Процесс денормализации зависит от СУБД в которой происходит работа.

К примеру, в PostgreSQL есть возможность создания материализованных представлений (MATERIALIZED VIEW), то есть можно создать МП, внутри которого будет выполнена логика по соединению данных из нескольких таблиц, произведена агрегация и другие действия, а результат этих действий будет физически храниться на жестком диске. Когда нужно будет актуализировать данные, достаточно обновить данные командой:
```
REFRESH MATERIALIZED VIEW имя_МП
```
Далее при обращении к МП данные будут читаться с диска, а не выполняться вся логика запроса, что сокращает время работы с данными во множество раз.

К примеру, в MySQL нет поддержки МП, здесь можно создать денормализованную таблицу, и с помощью триггерных функций формировать данные в денормализованной таблице. При изменении данных в нормализованных таблицах или при добавлении новых данных в эти таблицы должны отрабатывать триггеры, которые будут вызывать единую хранимую процедуру, которая будет производить необходимые вычисления, соединения данных и полученный результат записывать в денормализованную таблицу. Важно помнить, что при появлении избыточности или дублировании атрибутов необходимо контролировать целостность при внесении и модификации данных.

**Типы данных**

Выделяют следующие типы данных:
- Числовые,
- Строковые,
- Дата и время,
- Сложные, бинарные, геометрические...
При этом в зависимости от СУБД названия и поддержка разных типов данных может отличаться.

# Работа с данными (DDL/DML)

**SQL — историческая справка**

В начале 1970-х годов в одной из исследовательских лабораторий компании IBM была разработана экспериментальная реляционная СУБД IBM System R, для которой затем был создан специальный язык SEQUEL, позволявший относительно просто управлять данными в этой СУБД. Аббревиатура SEQUEL расшифровывалась как Structured English QUEry Language — «структурированный английский язык запросов». Позже язык SEQUEL был переименован в SQL. Когда в 1986 году первый стандарт языка SQL был принят ANSI (American National Standards Institute), официальным произношением стало [,es kju:' el] — эс-кью-эл

Целью разработки было создание простого непроцедурного языка, которым мог воспользоваться любой пользователь, даже не имеющий навыков программирования. Разработкой языка запросов занимались Дональд Чэмбэрлин (Donald D. Chamberlin) и Рэй Бойс (Ray Boyce). Пэт Селинджер (Pat Selinger) занималась разработкой стоимостного оптимизатора (cost-based optimizer), Рэймонд Лори (Raymond Lorie) занимался компилятором запросов.

SEQUEL был не единственным языком подобного назначения. В Калифорнийском Университете Беркли была разработана некоммерческая СУБД Ingres (являвшаяся дальним прародителем популярной сейчас некоммерческой СУБД PostgreSQL), которая являлась реляционной СУБД, но использовала свой собственный язык QUEL, который, не выдержал конкуренции по количеству поддерживающих его СУБД по сравнению с языком SQL.

Первыми СУБД, поддерживающими новый язык SQL, стали в 1979 году Oracle V2 для машин VAX от компании Relational Software (впоследствии ставшей компанией Oracle) и System/38 от IBM, основанная на System/R.

В 1986 году ANSI представил свою первую версию стандарта, описанную в документе ANSI X3.135-1986 под названием «Database Language SQL». Неофициально этот стандарт SQL-86 получил название SQL1. В 1987 году была завершена работа над версией стандарта ISO 9075-1987 под тем же названием. Разработка этого стандарта велась под патронажем Технического Комитета TC97. Именно его подразделение, именуемое как Подкомитет SC21, курировало разработку стандарта, что стало залогом идентичности стандартов ISO и ANSI для SQL1 (SQL-86).

**MySQL по CAP и PACELC**

Теоремы CAP и PACELC предназначены для распределенных баз данных. По умолчанию MySQL имеет репликацию master-slave. Таким образом, MySQL имеет просто первичные и вторичные узлы, соответственно для обработки данных используется только master и следовательно нарушается толерантность к разделению.

Получаем, что MySQL по теореме САР является СА системой. Но при этом MySQL можно сконфигурировать в CP систему, сформировав несколько распределенных master-slave узлов. По теореме PACELC MySQL относится к PC/EC системам, так как данные в системе должны быть согласованы в ущерб доступности данных и времени ответа кластера.

**MySQL архитектура**

MySQL — это открыто распространяемая СУБД и функционирует по модели клиент-сервер. Отличительной особенностью MySQL является возможность выбора подсистемы хранения, в которой обработка запросов и другие серверные задачи отделены от хранения и извлечения данных. Подобное разделение задач позволяет выбирать способ хранения данных, а также настраивать производительность, ключевые характеристики и так далее.

- Клиентские соединения
- Службы и утилиты
- Интерфейс
- Синтаксический анализатор
- Оптимизатор
- Кеши и буферы
- Подключаемые механизмы хранения
- Файловая система

**MySQL механизмы хранения**

Самыми популярными встроенными системами хранения в MySQL являются InnoDB и MyISAM. Менее популярными и востребованными являются Archive, Blackhole, CSV, Federated, Memory, Merge, Example и NDB Cluster. При этом с версии MySQL 8.0 поддержка механизма MyISAM прекращена, использование возможно, но дальнейшая судьба неизвестна.

**MySQL. InnoDB.**

Это механизм хранения по умолчанию для MySQL 5.5 и выше:
- придерживается требований ACID;
- поддерживает ограничения ссылочной целостности FOREIGN KEY;
- поддерживает функции фиксации, отката и восстановления после сбоя для защиты данных;
- поддерживает блокировку на уровне строк — это «согласованное чтение без блокировки» повышает производительность при использовании в многопользовательской среде;
- хранит данные в кластерных индексах, что уменьшает количество операций ввода-вывода для запросов на основе первичных ключей.

**MySQL. MyISAM.**

Это механизм хранения по умолчанию для MySQL 5.3 и ниже:
- управляет нетранзакционными таблицами;
- обеспечивает высокоскоростное хранение и извлечение;
- поддерживает полнотекстовый поиск;
- данные хранятся в кроссплатформенном формате, что позволяет переносить базы с сервера непосредственным копированием файлов, минуя промежуточные формы;
- допускается индексирование текстовых столбцов, в том числе и переменной длины и т.д

**Логический порядок**

SQL, как любой язык программирования имеет свою структуру и синтаксис. Прежде чем перейти к работе с этим языком, нужно запомнить, что структура запросов имеет свой порядок, но «под капотом» интерпретатор будет выполнять запрос в определенной логической последовательности, и от этого будут зависеть области видимости и с какими данными, что будет происходить.

**DDL**

Data Definition Language (DDL) – это группа операторов определения данных. С помощью этих операторов определяется структура базы данных и происходит работа с объектами базы данных.
В эту группу входят следующие операторы:
- CREATE – используется для создания объектов базы данных;
- ALTER – используется для изменения объектов базы данных;
- DROP – используется для удаления объектов базы данных.

**DML**

Data Manipulation Language (DML) – это группа операторов для манипуляции данными. С помощью этих операторов можно добавлять, изменять, удалять и получать данные из базы данных.
В эту группу входят самые распространенные операторы:
- SELECT – осуществляет выборку данных;
- INSERT – добавляет новые данные;
- UPDATE – изменяет существующие данные;
- DELETE – удаляет данные.

**DСL**

Data Control Language (DCL) – группа операторов определения доступа к данным. Эти операторы нужны для управления разрешениями доступа к данным и выполнения операций над объектами базы данных. Права назначаются на пользователя или на роли.
В данную группу входят следующие операторы:
- GRANT – предоставляет пользователю или группе разрешения на определенные операции с объектами;
- REVOKE – отзывает выданные разрешения;
- DENY – задает запрет, имеющий приоритет над разрешением (Отсутствует в MySQL)

**TCL**

Transaction Control Language (TCL) – группа операторов для управления транзакциями.
Эта группа состоит из следующих операторов:
- START TRANSACTION – служит для определения начала транзакции;
- COMMIT – применяет транзакцию;
- ROLLBACK – откатывает все изменения, сделанные в контексте текущей транзакции;
- SAVEPOINT – устанавливает промежуточную точку сохранения внутри транзакции.

# SQL

**Простые запросы. SELECT и FROM**

Для того чтобы получить данные, в запросе нужно указать:
- из какой таблицы хотим получить данные – предложение FROM;
- какие данные хотим вывести в результат – предложение SELECT.

Оператор * означает, что хотим вывести в результат все столбцы из таблицы customer, если нужно вывести определенные столбцы, то их нужно перечислить.

**Простые запросы. ALIAS** - Алиасы (псевдонимы) нужны для того, чтобы задавать временные названия для столбцов и таблиц. Алиасы для столбцов позволяют дать понятные названия для вычисляемых значений, а краткие алиасы для таблиц позволяют упростить написание запросов. Для задания алиасов используется оператор AS, но его можно опускать. Чтобы не писать полные названия таблиц, зададим в запросе на следующем слайде краткие алиасы и для вычисляемого столбца также зададим временное имя с обозначением результата.

**Простые запросы. ORDER BY** - В независимости от того, в каком порядке данные хранятся в базе данных, SQL возвращает результат в непредсказуемом порядке. Чтобы явно задать порядок сортировки, используется оператор ORDER BY. Для того чтобы задать направление сортировки, нужно указывать ASC – от меньшего к большему (по умолчанию) или DESC – от большего к меньшему. Давайте возьмем запрос с получением стоимости аренды фильма за день и отсортируем по стоимости аренды за день от большего к меньшему, а потом по названию фильма.

**Простые запросы. LIMIT и OFFSET**
- Если нужно получить первые N записей из результата, используется оператор LIMIT.
- Если нужно исключить из результата первые N записей, используется оператор OFFSET.

**Простые запросы. DISTINCT** - Для получения уникальных значений в результате, используется оператор DISTINCT.

**Простые запросы. WHERE** - Как правило, при получении данных нужно указать условия, по которым нужно их отфильтровать, для этого используется оператор WHERE. Если условий нужно использовать несколько, то используются логические операторы AND и OR. Для отрицания в условии используется оператор NOT.

**Простые запросы. CAST** - При работе с разными типами данных часто нужно преобразовывать один тип данных к другому, для этого используется оператор CAST

**Работа с числами**

**Округление** -  Для округления в MySQL используются следующие функции:
- ROUND – округляет число до заданного числа десятичных знаков
- TRUNCATE – усекает число до указанного числа десятичных знаков
- FLOOR – возвращает наибольшее целочисленное значение, которое меньше или равно числу
- CEIL – возвращает наименьшее целочисленное значение, которое больше или равно числу
- ABS – возвращает абсолютное (положительное) значение числа.

**Арифметические операторы** - SQL поддерживает все основные арифметические операторы:
- + – * / – стандартные операторы
- POWER – возведение в степень
- SQRT – возвращает квадратный корень числа
- COS, SIN, TAN, COT, etc – геометрические операторы
- DIV – целочисленное деление
- % – остаток от деления
- GREATEST/LEAST – возвращает наибольшее/наименьшее значение из списка,
- RAND – возвращает случайное число в диапазоне от 0 (включительно) до 1 (исключительно).

**Работа со строками** - Разберем основные функции для работы с подстроками и строками:
- CONCAT, CONCAT_WS – соединяет строки в одну, _WS – по сепаратору
- LENGTH – возвращает длину строки в байтах
- CHAR_LENGTH – возвращает длину строки в символах
- POSITION – возвращает позицию первого вхождения подстроки в строку
- SUBSTR – извлекает подстроку из строки
- LEFT / RIGHT – извлекает ряд символов из строки начиная слева / справа
- LOWER / UPPER – преобразует строку в нижний / верхний регистр
- INSERT – вставляет подстроку в строку в указанной позиции и для определенного количества символов
- TRIM – удаляет начальные и конечные пробелы из строки
- REPLACE – заменяет все вхождения подстроки в строке на новую подстроку
- SUBSTRING_INDEX – возвращает подстроку строки до того, как появится указанное число разделителей

Выражение LIKE возвращает true, если строка соответствует заданному шаблону. Выражение NOT LIKE возвращает false, когда LIKE возвращает true и наоборот. Если шаблон не содержит знаков процента и подчеркиваний, тогда шаблон представляет в точности строку и LIKE работает как оператор сравнения. Подчеркивание (_) в шаблоне подменяет (вместо него подходит) любой символ. Знак процента (%) подменяет любую (в том числе и пустую) последовательность символов

**Работа с датами и временем** - Разберем основные функции для работы с датами и временем:
- NOW / CURDATE – возвращает текущие дату и время / дату
- DATE_ADD – добавляет интервал времени/даты к дате, а затем возвращает дату, работает как с датой, так и со временем
- DATE_SUB – вычитает интервал времени/даты из даты, а затем возвращает дату, работает как с датой, так и со временем
- YEAR / MONTH / DAY — возвращает год / месяц / день месяца для заданной даты
- EXTRACT – извлекает часть из заданной даты
- DATEDIFF – возвращает количество дней между двумя значениями даты
- QUARTER – возвращает квартал года для заданного значения даты
- DATE_FORMAT – форматирует указанную дату
- TIME_FORMAT – форматирует время по заданному формату
- DATE – извлекает дату из выражения datetime

**BETWEEN** - Для того чтобы найти значения в заданном диапазоне, используется оператор BETWEEN. Данный оператор можно использовать с числами, строками и датами. Крайние значения включаются в результат

**JOIN** - В SQL JOIN’ы используются для соединения нескольких таблиц и получения из них данных. Существуют следующие типы JOIN:
- INNER JOIN
- LEFT JOIN
- RIGHT JOIN
- FULL JOIN
- CROSS JOIN

В LEFT OUTER JOIN, RIGHT OUTER JOIN и FULL OUTER JOIN ключевое слово OUTER можно опустить, оно не обязательно для использования. Также при использовании INNER JOIN можно опустить ключевое слово INNER. При работе с JOIN желательно использовать алиасы, для удобства чтения/написания запросов и указания, из каких таблиц какие столбцы нужно получать.

- INNER JOIN возвращает данные по строкам, содержащим одинаковые значения
- LEFT JOIN возвращает все данные из левой таблицы. Если по ним есть совпадения в правой, они обогащаются соответствующими данными, иначе туда записывается специальное значение NULL. Чтобы получить только те строки, которые не содержат данных в правой таблице, можно использовать оператор WHERE
- RIGHT JOIN — это обратная версия LEFT JOIN. Возвращает все данные из правой таблицы. Если по ним есть совпадения в левой, они обогащаются соответствующими данными, иначе туда записывается специальное значение NULL
- FULL JOIN не поддерживается MySQL. Рассмотрим его синтаксис в других СУБД и как реализовать в MySQL. FULL JOIN позволяет получить сопоставление по всем строкам в обеих таблицах. То есть получаем все данные из левой и правой таблиц, а там, где сопоставлений нет — добавляются значения NULL. Чтобы получить список уникальных строк из обеих таблиц, можно также воспользоваться оператором WHERE
- CROSS JOIN — это Декартово произведение, когда каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы. В результате получается таблица со всеми возможными сочетаниями строк обеих таблиц

UNION / EXCEPT -  Если при работе с JOIN соединение данных происходит «слева» или «справа», то при работе с операторами UNION или EXCEPT работа происходит «сверху» и «снизу»
- При объединении данных через оператор UNION в результате будет список уникальных значений для двух таблиц
- При объединении данных через оператор UNION ALL в результате будет список всех значений для двух таблиц
- При использовании оператора EXCEPT из значений, полученных в верхней части запроса, будут вычтены значения, которые совпадут со значениями, полученными в нижней части запроса

**Агрегатные функции**

**Агрегация** — когда данные группируются по ключу, в качестве которого выступает один или несколько атрибутов, и внутри каждой группы вычисляются некоторые статистики.
- SUM — возвращает общую сумму числового столбца
- COUNT — возвращает количество строк, соответствующих заданному критерию
- AVG — возвращает среднее значение числового столбца
- MIN — возвращает наименьшее значение выбранного столбца
- MAX — возвращает наибольшее значение выбранного столбца

**Группировка данных**

GROUP BY — агрегирующий оператор, с помощью которого можно формировать данные по группам и уже в рамках этих групп получать значения с помощью агрегатных функций. Группировать можно как по одному атрибуту, так и по нескольким. При этом важно помнить, что все значения указанные в SELECT, которые не указаны внутри агрегатных функций, должны быть указаны в операторе GROUP BY.

Если при использовании агрегации и группировки данных нужно вывести несколько столбцов из одной таблицы, то вместо указания всех этих столбцов в GROUP BY можно использовать Функциональную Зависимость.

**HAVING** - Вспоминая логический порядок инструкции SELECT: оператор WHERE фильтрует данные до группировки, а чтобы отфильтровать сгруппированные данные, используется оператор HAVING

**Подзапросы**

**Подзапрос** — это SELECT, результаты которого используются в другом SELECT. Подзапросы нужны для разделения логики в основном запросе.

Подзапросы могут использоваться в любой части запроса, в зависимости от этой части запроса подзапросы могут возвращать:
- отдельное значение,
- таблицу,
- одномерный массив.
Если подзапрос возвращает таблицу, подзапросу обязательно задается алиас

**CASE** - Выражение CASE в SQL представляет собой общее условное выражение, напоминающее операторы if/else в других языках программирования. Типы данных всех выражений результатов должны приводиться к одному выходному типу.

**IFNULL** - Функция IFNULL позволяет возвращать альтернативное значение, если выражение возвращает NULL.

**COALESCE** - Функция COALESCE позволяет возвращать первое значение из списка, которое не равно NULL

# Indexes
Индексы

**План запроса**

**EXPLAIN** - Оператор EXPLAIN демонстрирует этапы выполнения запроса и может быть использован для оптимизации. По результату работы EXPLAIN можно выяснить, где в запросе узкие места, нужно ли использовать индексы, верный ли порядок и алгоритмы джойна выбраны при соединении таблиц и так далее.

**EXPLAIN** работает с SELECT, DELETE, INSERT, REPLACE и UPDATE операторами. В MySQL 8.0.19 и более поздних версиях он также работает с оператором TABLE. Оператор EXPLAIN выводит план запроса

При использовании оператора EXPLAIN можно указать формат вывода с помощью оператора FORMAT:
- TRADITIONAL — вывод в табличном формате;
- JSON — вывод в формате JSON;
- TREE — древовидный вывод с более точными описаниями обработки запросов, чем TRADITIONAL

**EXPLAIN ANALYZE** -  В MySQL 8.0.18 добавлена возможность использования оператора EXPLAIN ANALYZE, который запускает оператор и производит EXPLAIN вывод вместе с синхронизацией и дополнительной, основанной на итераторах, информацией о том, как ожидания оптимизатора совпадают с фактическим выполнением. EXPLAIN ANALYZE всегда использует TREE формат.

Для каждого итератора предоставляется следующая информация:
- ориентировочная стоимость исполнения,
- расчетное количество возвращаемых строк,
- фактическое время возврата первой строки в миллисекундах,
- фактическое время возврата всех строк в миллисекундах (при наличии нескольких циклов этот пункт показывает среднее время на цикл),
- количество строк, возвращаемых итератором,
- количество циклов

**Индексы**

**INDEX** – это инструмент, который позволяет оптимизировать выборку из базы данных, значительно сокращая время на получение данных

Без индекса MySQL должен начать с первой строки, а затем прочитать всю таблицу, чтобы найти соответствующие строки. Чем больше таблица, тем больше это стоит. Если таблица имеет индекс для рассматриваемых столбцов, MySQL может быстро определить позицию для поиска в середине файла данных, не просматривая все данные. Это намного быстрее, чем последовательное чтение каждой строки.

В MySQL **индексы** можно разделить на следующие **типы**:
- B-TREE — PRIMARY KEY, UNIQUE, INDEX и FULLTEXT,
- R-TREE — пространственные типы данных,
- INVERTED — в механизме хранения InnoDB для FULLTEXT,
- HASH — только в механизме хранения Memory.

**B-TREE** — древовидная структура данных, популярная для использования в индексах БД. Структура всегда отсортирована, что обеспечивает быстрый поиск точных совпадений (оператор равенства) и диапазонов (например, больше, меньше и операторов BETWEEN). Этот тип индекса доступен для большинства механизмов хранения, поскольку узлы B-TREE могут иметь много дочерних элементов. B-TREE не то же самое, что двоичное дерево, которое ограничено двумя дочерними элементами на узел

**R-дерево** (англ. R-trees) — древовидная структура данных (дерево), предложенная в 1984 году Антонином Гуттманом. Она подобна B-дереву, но используется для организации доступа к пространственным данным, то есть для индексации многомерной информации, такой, например, как географические данные с двумерными координатами (широтой и долготой).
Эта структура данных разбивает многомерное пространство на множество иерархически вложенных и, возможно, пересекающихся, прямоугольников (для двумерного пространства). В случае трехмерного или многомерного пространства это будут прямоугольные параллелепипеды (кубоиды) или параллелотопы.

**INVERTED - Инвертированный индекс** – это полнотекстовый индекс, структура данных, в которой для каждого слова коллекции документов в соответствующем списке перечислены все документы в коллекции, в которых оно встретилось.

**HASH-индексы** были предложены Артуром Фуллером, и предполагают хранение не самих значений, а их хэшей, благодаря чему уменьшается размер и увеличивается скорость обработки индексов из больших полей. Таким образом, при запросах с использованием HASH-индексов, сравниваться будут не искомое со значением поля, а хэш от искомого значения с хэшами полей. Из-за нелинейности хэш-функций данный индекс нельзя сортировать по значению, что приводит к невозможности использования в сравнениях больше/меньше и «is null». Кроме того, так как хэши не уникальны, то для совпадающих хэшей применяются методы разрешения коллизий

**ADAPTIVE HASH** используется для оптимизации InnoDB таблиц, которые могут ускорить поиски с использованием строгого равенства и IN операторами, путем построения HASH-индекса в памяти. MySQL отслеживает поиск по индексу для InnoDB таблиц, и если запросы могут выиграть от HASH-индекса, он автоматически строит индекс для часто используемых страниц индекса. В некотором смысле ADAPTIVE HASH настраивает MySQL во время выполнения, чтобы использовать преимущества большой основной памяти, приближаясь к архитектуре баз данных с основной памятью. ADAPTIVE HASH всегда строится на основе существующего индекса B-TREE в таблице.

**Уникальные индексы** - Индексы разделяются на обычные и уникальные. Когда происходит поиск по обычному индексу, то есть по не уникальным значениям, то после первого нахождения соответствия поиск будет продолжен. В случае с уникальным индексом, после нахождения искомого значения поиск будет остановлен. Уникальные ключи работают так же, как и первичные ключи, только их может быть любое количество.

**Кластерные индексы** - Обычные индексы являются не кластерными, и сам индекс хранит только ссылки на записи таблицы. Когда происходит работа с индексом, определяется только список первичных ключей записей, подходящих под запрос. После этого происходит еще один запрос — для получения данных каждой записи из этого списка.
Кластерные индексы сохраняют данные записей целиком, а не ссылки на них. При работе с таким индексом не требуется дополнительной операции чтения данных. Первичные ключи таблиц InnoDB являются кластерными и выборки по ним происходят эффективно.

**Стоимость индексов**

При использовании индексов происходят дополнительные операции записи на жесткий диск. Таким образом при каждом обновлении или добавлении данных в таблицу, происходит также запись и обновление данных в индексе. Если в операциях SELECT индексы ускоряют работу, то в операциях INSERT и UPDATE время увеличивается, как и занимаемое место на жестком диске.

# Репликация и масштабирование 1

**Репликация**

**Репликация** — это процесс, под которым понимается копирование данных из одного источника на другой (или на множество других) и наоборот. С точки зрения базы данных — это механизм копирования базы данных и создания копий или дополнений существующих объектов

**Виды репликации**
- **Синхронная** - если данная реплика обновляется, все другие реплики того же фрагмента данных также должны быть обновлены в одной и той же транзакции. Логически это означает, что существует лишь одна версия данных.
- **Асинхронная** — обновление одной реплики распространяется на другие спустя некоторое время, а не в той же транзакции. Таким образом, при асинхронной репликации вводится задержка или время ожидания, в течение которого отдельные реплики могут быть фактически не идентичными

**Преимущества репликации**
- повышение производительности чтения данных;
- повышение отказоустойчивости;
- распространение данных между серверами повышает надежность, доступность и скорость;
- распределение нагрузки;
- тестирование новых конфигураций;
- резервное копирование.

**Репликация типа Master-Slave**

**Репликация типа Master-Slave** часто используется для обеспечения отказоустойчивости приложений. Кроме этого, она позволяет распределить нагрузку на базу данных между несколькими серверами (репликами)
- **Master** — это основной сервер БД, куда поступают все данные. Все изменения в данных (добавление, обновление, удаление) должны происходить на этом сервере.
- **Slave** — это вспомогательный сервер БД, который копирует все данные с мастера. С этого сервера следует читать данные. Таких серверов может быть несколько.

Репликация выполняется по следующим шагам:
- Master записывает изменения данных в журнал (binary log);
- Slave копирует изменения двоичного журнала в свой, который называется журналом ретрансляции (relay log);
- Slave воспроизводит изменения из журнала ретрансляции,применяя их к собственным данным.

Репликация бывает двух подходов: **покомандная и потоковая**
- **Покомандная репликация** — в журнал master протоколируются запросы изменения данных (INSERT, UPDATE, DELETE), на slave повторяются.
- **Построчной репликации** в журнале запишутся изменения данных, тоже произойдет и на slave

**Репликация master-master**

**Репликация master-master** позволяет копировать данные с одного сервера на другой. Эта конфигурация добавляет избыточность и повышает эффективность при обращении к данным. Master-Master репликации – это настройка обычной Master-Slave репликации, только в обе стороны (каждый сервер является мастером и слейвом одновременно)

**Настройка master-slave репликации**

Установка master:
```
docker run -d --name replication-master -e MYSQL_ALLOW_EMPTY_PASSWORD=true -v
~/path/to/world/dump:/docker-entrypoint-initdb.d mysql:8.0
```
Установка slave:
```
docker run -d --name replication-slave -e MYSQL_ALLOW_EMPTY_PASSWORD=true
mysql:8.0
```
Для реализации взаимодействия создадим мост и сеть:
```
docker network create replication
docker network connect replication replication-master
docker network connect replication replication-slave
```
Для управления реализации настроек обновим и установим в контейнеры инструменты.

Для Master:
```
docker exec replication-master apt-get update && docker exec replication-master
apt-get install -y nano
```
Для Slave:
```
docker exec replication-slave apt-get update && docker exec replication-slave
apt-get install -y nano
```
Создадим учетную запись Master для сервера репликации:
```
docker exec -it replication-master mysql
```
В контейнере выполним:
```
mysql> CREATE USER 'replication'@'%';
mysql> GRANT REPLICATION SLAVE ON *.* TO 'replication'@'%';
```
Изменим конфигурацию сервера:
```
docker exec -it replication-master bash
~ nano /etc/mysql/my.cnf
```
my.cnf -> секция [mysqld] добавляем следующие параметры:
```
server_id = 1
log_bin = mysql-bin
```
При изменении конфигурации сервера требуется перезагрузка:
```
docker restart replication-master
```
После требуется зайти в контейнер и проверить состояние:
```
docker exec -it replication-master mysql
mysql> SHOW MASTER STATUS:
```
Следующим шагом требуется выполнить слепок системы и заблокировать все изменения на сервер:
```
mysql> FLUSH TABLES WITH READ LOCK;
```
После данных манипуляций выхода из контейнера и выполняем процесс mysqldump для экспорта базы данных, например:
```
docker exec replication-master mysqldump world > /path/to/dump/on/host/world.sql
```
После, следует зайти обратно в контейнер и вывести настройки master сервера (они понадобятся при настройке slave):
```
docker exec -it replication-master mysql
mysql> SHOW MASTER STATUS;
```
**!!! Важно запомнить File и Position**

Снимаем блокировку базы данных:
```
mysql> UNLOCK TABLES;
```
Master готов, переходим к slave:
```
docker cp /path/to/dump/on/host/world.sql replication-slave:/tmp/world.sql
docker exec -it replication-slave mysql
mysql> CREATE DATABASE `world`;
docker exec -it replication-slave bash
~ mysql world < /tmp/world.sql
```
Открываем конфигурационный файл на Slave my.cnf
```
docker exec -it replication-slave bash
~ nano /etc/mysql/my.cnf
```
my.cnf -> секция [mysqld] добавляем следующие параметры:
```
log_bin = mysql-bin
server_id = 2
relay-log = /var/lib/mysql/mysql-relay-bin
relay-log-index = /var/lib/mysql/mysql-relay-bin.index
read_only = 1
```
Перезагружаем Slave:
```
docker restart replication-slav
```
Следующим шагом требуется прописать в базе данных на сервер slave, кто является master и данные полученные в File и Position:
```
docker exec -it replication-slave mysql
mysql> CHANGE MASTER TO MASTER_HOST='replication-master',
MASTER_USER='replication', MASTER_LOG_FILE='mysql-bin.000001',
MASTER_LOG_POS=156;
```
Далее запускаем журнал ретрансляции, и проверим статус операций
```
mysql> START SLAVE;
mysql> SHOW SLAVE STATUS\G
```
**Ключевые настройки**
- Slave_IO_State, Slave_SQL_State — состояние IO потока, принимающего двоичный журнал с мастера, и состояние потока, применяющего журнал ретрансляции.
- Read_Master_Log_Pos — последняя позиция, прочитанная из журнала мастера.
- Relay_Master_Log_File — текущий файл журнала мастера.
- Seconds_Behind_Master — отставание данных в секундах.
- Last_IO_Error, Last_SQL_Error — ошибки репликации, если они есть

**Настройка master-master репликации**

Режим Master-Master:
```
docker run -d --name replication-master-one -e MYSQL_ALLOW_EMPTY_PASSWORD=true
-v ~/path/to/world/dump:/docker-entrypoint-initdb.d mysql:8.0
docker run -d --name replication-master-two -e MYSQL_ALLOW_EMPTY_PASSWORD=true
-v ~/path/to/world/dump:/docker-entrypoint-initdb.d mysql:8.0
```
Конфигурационный файл my.conf должен содержать:
```
server_id = 1
log_bin = mysql-bin #на первом
server_id = 2
log_bin = mysql-bin #на втором
```
На втором сервере выполнить:
```
slave stop;
CHANGE MASTER TO MASTER_HOST = 'replication-master-one', MASTER_USER =
'replicator', MASTER_PASSWORD = 'password', MASTER_LOG_FILE =
'mysql-bin.000001', MASTER_LOG_POS = 107;
slave start;
```
На первом:
```
slave stop;
CHANGE MASTER TO MASTER_HOST = 'replication-master-two', MASTER_USER =
'replicator', MASTER_PASSWORD = 'password', MASTER_LOG_FILE =
'mysql-bin.000001', MASTER_LOG_POS = 107;
slave start;
```
Важно добавить пользователей на обоих серверах:
```
create user 'replicator'@'%' identified by 'password';
create database example;
grant replication slave on *.* to 'replicator'@'%';
```
Перезагружаемся и проверяем.

**Тестирование**

Меняем данные на Server-Master:
```
docker exec -it replication-master mysql
mysql> USE world;
mysql> INSERT INTO city (Name, CountryCode, District, Population) VALUES
('Test-Replication', 'ALB', 'Test', 42);
```
Проверяем на slave:
```
docker exec -it replication-slave mysql
mysql> USE world;
mysql> SELECT * FROM city ORDER BY ID DESC LIMIT 1;
```

# Масштабирование (Репликация и масштабирование 2)

**Масштабирование** — это процесс разделения данных на группы и выделение их на отдельные сервера. Основные виды масштабирования:
- репликация (Master-slave, master-master),
- партицирование,
- шардинг.
Кластеризация — это как репликация с каким-либо методом масштабирования

Типы масштабирования:
- scaling up — масштабирование вверх,
- scaling out — масштабирование горизонтальное,
- scaling back — часть данных открыты, часть данных заархивированы,
- federation — доступ к удаленным данным

**Scaling out - Горизонтальное масштабирование**

При масштабировании по горизонтали данные распределяются по нескольким серверам с помощью репликации, а далее используются slave-серверы на чтение. При этом происходит разделение (partition) данных по нескольким нодам. Нода – функциональный блок в MySQL, это может быть отдельный сервер.

Ноды бывают четырех типов:
-  активный master-сервер и пассивный репликационный slave-сервер (настраивали),
- master-сервер и несколько slave-серверов (настраивали),
- активный сервер со специальным механизмом репликации – distributed replicated block device (DRBD),
- SAN-кластер

**Функциональное разделение** — данные разбиваются на таблицы так, что они никогда не соединяются между собой (портирование).
**Data sharding** — механическое разделение огромных объемов однотипных данных на несколько частей (shard — шардинг). С точки зрения реализации, это наиболее трудоемкий вариант

**Шардинг** - (shard — сегментировать)

Шардинг (иногда шардирование) — это техника масштабирования при работе с данными. Его суть в разделении (партиционирование) базы данных на отдельные части так, чтобы каждую из них можно было вынести на отдельный сервер. Существует два вида шардинга:
- вертикальный;
- горизонтальный

**Вертикальный шардинг** — это выделение таблицы или группы таблиц на отдельный сервер. Например, существует две таблицы users и password. Таблицу users оставляем на одном сервере, а таблицу password переводим на другой.

**Горизонтальный шардинг** — это разделение одной таблицы на разные сервера. Это необходимо использовать для огромных таблиц, которые не умещаются на одном сервере. 

**Разделение таблицы на части делается по следующему принципу:**
- на нескольких серверах создается одна и та же таблица (только структура, без данных);
- в приложении выбирается условие, по которому будет определяться нужное соединение (например, четные на один сервер, а нечетные — на другой);
- перед каждым обращением к таблице происходит выбор нужного соединения

**Storage Area Network**

Сеть хранения данных представляет собой архитектурное решение для подключения внешних устройств хранения данных (дисковые массивы, ленточные библиотеки) к серверам таким образом, чтобы операционная система распознала подключённые ресурсы как локальные

# Резервное копирование

**Резервное копирование** — процесс создания копии данных на носителе (жёстком диске, дискете и т. д.), предназначенном для восстановления данных в оригинальном или новом месте их расположения в случае их повреждения или разрушения. Резервное копирование необходимо для возможности быстрого и недорогого восстановления БД в случае утери рабочей копии информации по какой-либо причине.

**Виды и типы резервного копирования**
- Полное резервное копирование (Full backup)
- Инкрементные бэкапы (Incremental backup)
- Дифференциальный бэкап (differential backup)
- Холодное резервирование БД
- Горячее резервирование БД
- Репликация

**Полное резервное копирование** (Full backup) - Данный метод создает полную копию набора исходных данных. В данном случае копируется весь каталог с файлами БД либо создается образ диска или системы, где находится база.

**Преимущества:**
- быстрое восстановление данных,
- простое управление,
- все данные содержаться в одной резервной копии.
**Недостатки:**
- требует много места для хранения резервных копий,
- высокая загрузка сети,
- длительное выполнение резервного копирования

**Инкрементные бэкапы (Incremental backup)** - Инкрементное резервное копирование использует полную копию, как начальную точку. Затем выполняется резервное копирование только блоков данных, которые были изменены с момента последнего резервного задания, с заданным периодом выполнения задания. В зависимости от политики хранения резервных копий через определенный период создается новая полная копия для повторения цикла

**Преимущества:**
- высокая скорость резервного копирования (копируются только блоки измененных данных),
- меньше места для хранения (по сравнению с полным),
- большее количество точек восстановления

**Недостатки:**
- низкая скорость восстановления данных (необходимо восстановить как начальную полную копию, так и все последующие блоки);
- менее надежна (зависит от целостности всех блоков в цепочке).

**Дифференциальный бэкап (differential backup)** — это тип резервного копирования файлов, при котором копируются не все исходные файлы, а только новые и измененные с момента создания предыдущей полной копии. Он является чем-то средним между полным резервным копированием и инкрементальным. Название этого типа произошло от английского слова Differential backup и является накопительным, т.е. каждая следующая копия содержит все новые/измененные файлы с момента создания предыдущей полной резервной копии.

**Преимущества:**
- Относительно небольшой размер разностной резервной копии, по сравнению с полной;
- Скорость создания в разы выше, чем полного бэкапа;
- Для восстановления файлов потребуется последний созданный полный бэкап и последний дифференциальный.

**Недостатки:**
- Избыточность данных, так как дифференциальный бэкап является накопительным

**Холодное резервирование БД** - Холодное резервное копирование выполняется на уровне операционной системы при остановленной базе данных — резервируются файлы, составляющие базу данных файлы данных, управляющие файлы, файл параметров

**Преимущества:**
- быстрое восстановление данных,
- простое управление,
- все данные содержаться в одной резервной копии

**Недостатки:**
- можно восстановить только то состояние базы данных, которое было в момент остановки;
- транзакции, сделанные после рестарта базы, в резервную копию не попадут;
- не у каждой базы данных есть технологическое окно, когда базу можно остановить

**Горячее резервирование БД** - При горячем резервировании база данных включена и открыта для потребителей. Копия базы данных приводится в согласованное состояние путем автоматического приложения к ней журналов резервирования по окончании копирования файлов данных.

**Преимущества:**
- База данных может использоваться во время резервного копирования;
- База данных может восстановиться до определенного момента времени;
- Высокая скорость восстановления;
- Почти все объекты базы данных могут быть восстановлены

**Недостатки:**
- В момент начала копирования содержимое базы данных может не совпадать с содержимым файлов;
- Во время копирования содержимое базы может меняться;
- Поскольку запись данных в базу и чтение файлов БД никак не синхронизированы, программа резервного копирования может прочитать некорректную страницу, в которой половина будет от старой версии страницы, а другая половина – от новой.

**Репликация** - Идея репликации основана на том, что кроме «главного» сервера («Мастера») постоянно работают ведомые сервера («слейвы»), которые получают инкрементные бэкапы с мастера в режиме реального времени.

**Восстановление данных** — процесс восстановления базы данных до исходного состояния из имеющейся резервной копии. В процессе обычно используются утилиты для восстановления, поставляемые в комплекте с СУБД. Как правило, существует подробная документация, как проводить восстановление

**Резервное копирование и восстановление PostgreSQL**
- Выгрузка в SQL;
- Резервное копирование на уровне файлов;
- Непрерывное архивирование и восстановление.

**Выгрузка в SQL** - Идея, стоящая за этим методом, заключается в генерации текстового файла с командами SQL, которые при выполнении на сервере пересоздадут базу данных в том же самом состоянии, в котором она была на момент выгрузки

**Резервное копирование на уровне файлов** - Альтернативной стратегией резервного копирования является непосредственное копирование файлов, в которых Postgres хранит содержимое базы данных;

**Непрерывное архивирование и восстановление** - В процессе работы Postgres ведёт журнал предзаписи (WAL). В этот журнал записываются все изменения, вносимые в файлы данных. Если происходит крах, целостность СУБД может быть восстановлена в результате «воспроизведения» записей, зафиксированных после последней контрольной точки. Однако наличие журнала делает возможным использование третьей стратегии копирования баз данных: можно сочетать резервное копирование на уровне файловой системы с копированием файлов WAL. Если потребуется восстановить данные, мы можем восстановить копию файлов, а затем воспроизвести журнал из скопированных файлов WAL, и таким образом привести систему в нужное состояние

**Резервное копирование и восстановление MySql**
- Копирование файлов базы;
- Копирование через текстовые файлы;
- Инкрементные бэкапы;
- Репликация

**Копирование файлов базы** - Базу данных MySQL можно скопировать, если временно выключить MySQL-сервер и просто скопировать файлы из папки /var/lib/mysql/db/. Если сервер не выключить, вероятна потеря и порча данных. Для больших нагруженных баз эта вероятность близка к 100%. При первом запуске с «грязной» копией базы данных MySQL- сервер начнет процесс проверки всей базы, который может затянуться на часы

В большинстве «живых» проектов регулярное выключение сервера БД на длительное время неприемлемо. Для решения этой проблемы применяется трюк, основанный на снэпшотах файловой системы.

**Общая схема действий такова:**
- блокируются все таблицы,
- сбрасывается файловый кэш БД,
- делается снэпшот файловой системы,
- разблокируются таблицы.

Далее файлы спокойно копируются из снэпшота, который затем уничтожается. «Блокирующая» часть такого процесса занимает время порядка нескольких секунд, что уже терпимо. В качестве расплаты на какое-то время, пока «жив» снэпшот, снижается производительность файловых операций, что в первую очередь бьет по скорости операций записи в базу.

**Копирование через текстовые файлы** - Для того, чтобы считать в бэкап данные из production-базы, не обязательно дергать файлы. Можно выбрать данные запросом и сохранить их в текстовый файл. Для этого используется SQL-команда SELECT INTO OUTFILE и парная ей — LOAD DATA INFILE.

Выгрузка производится построчно (можно отобрать для сохранения только нужные строки, как в обычном SELECT). Структура таблиц нигде не указывается — об этом должен заботиться программист. Он также должен позаботиться о включении команд SELECT INTO OUTFILE в транзакцию, если это необходимо для обеспечения целостности данных. На практике SELECT INTO OUTFILE используется для частичного бэкапа очень больших таблиц, которые нельзя скопировать никаким другим образом

**Инкрементные бэкапы**  - Традиционно рекомендуют держать 10 бэкапов: по одному на каждый день недели, а также бэкапы двухнедельной, месячной и квартальной давности — это позволит достаточно глубоко откатиться в случае порчи каких-либо данных. Храниться бэкапы должны точно не на том же диске, что и живая база, и не на том же сервере. Эти требования могут стать проблемой для больших баз. Частично решить эту проблему позволяют инкрементные бэкапы, когда полный бэкап делается, скажем, только по воскресеньям, а в остальные дни пишутся только данные, добавленные или измененные за прошедшие сутки.

**Репликация** -  Реплика — это полная копия базы, но это не резервная копия! Идея репликации основана на том, что кроме «главного» сервера («Мастера») постоянно работают ведомые сервера MySQL («слейвы»), которые получают инкрементные бэкапы с мастера в режиме реального времени.Таким образом, время отката уменьшается почти до сетевого лага. В случае краха Мастера можно оперативно назначить «новым Мастером» один из слейвов и перенаправить клиентов на него. Кроме того, слейвы могут обрабатывать запросы на чтение данных (SELECT-ы); это можно использовать для выполнения каких-то расчетов или снижения нагрузки на мастера

**Мониторинг состояния бэкапов**

После создания любых типов бэкапов обязательно следить за их состоянием.

Важные аспекты, на которые следует обратить внимание:
- восстанавливаемость,
- целостность файлов и цепочки (в случае инкрементальных бэкапов),
- свободное место для хранения.
Удобным инструментом для такого мониторинга является Zabbix
