# git

**Основы git**

**Системы контроля версий (СКВ, VCS, Version Control Systems)** позволяют разработчикам сохранять все изменения, внесенные в код. СКВ также позволяют нескольким разработчикам работать над одним проектом и сохранять внесенные изменения независимо друг от друга.

**Git** — это инструмент, позволяющий реализовать **распределенную систему контроля версий**. С помощью git можно откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.

**Репозиторием** называют хранилище кода и историю его изменений. Git работает локально и все ваши репозитории хранятся в определенных папках на жестком диске.

**Коммиты** - Каждая точка сохранения называется коммит (commit). У каждого commit есть hash (уникальный id) и комментарий. Из таких commit-ов собирается ветка. Ветка — это история изменений. У каждой ветки есть свое название.

**Ветвления** - Ветки имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе.

**Установка и настройка репозитория**

Установка git из репозитория:
```
sudo apt-get install git
```
Настройка git для корректного отображения автора коммитов:
```
git config --global user.name "My Name"
git config --global user.email myEmail@example.com
```
Инициализация репозитория:
```
git init - делаем в дитектории которую используем под проект проявляется папка .git где лежит все необходимое для git-а
```
Просмотр текущего статуса: **git status**

**Работа с git**

Чтобы добавить файлы для отслеживания используется команда:
```
git add имя_файла
```
После этого изменения файла начнут отслеживаться и его можно закоммитить:
```
git commit -m "some useful comment here"
git log - покажет инфо о коммите (зеленый main - локально, красный - и удаленно)
git log --oneline - короткое инфо
git log --oneline --graph - визуально показывет дерево коммитов
git show - изменения в последнем коммите
```
```
git config --global alias.st status - алиас для частых комманд
git st = git status
```
```
git branch -v - покажет существующие ветки
git branch develop - создание новой ветки develop
git checkout -b develop - создаем ветку и сразу в нее переходим
```
Перед каждым коммитом необходимо проиндексировать файлы, которые будут закоммичены. Это можно сделать с помощью:
```
git add .
```
либо добавив ключ:
```
git commit -a
```
Последний коммит в ветке обозначается как HEAD. Это сделано для упрощенного доступа к нему.

**Работа с git: отмена изменений**

До выполнения индексации:
```
git checkout имя файла
```
После индексации:
```
git reset HEAD имя файла
```
```
git reset --hard commit-id - полный откат к коммиту по id, удаление файлов и логов
git reset --soft commit-id - удаляется логи и возвращаются изменения файлов до коммита
```
Откат изменений коммита осуществляется с помощью revert:
```
git revert HEAD --no-edit - в логах остается информация об откате
```
Вместо HEAD можно указать любой id коммита из истории. Просмотр истории:
```
git log
```
**Работа с ветками**

Создание веток:
```
git checkout -b имя_ветки
git checkout master - переключение в master
```
```
git checkout b031dd4 - смотрим состояние первого коммита, не можем редактировать, поэтому
git switch -c switched_develop - создаем новую ветку с первого коммита и переключаемся на нее
```
Слияние веток:
```
git merge develop - переносим в ветку в которой находимся из develop
```
**Клонирование репозитория**
Клонировать репозиторий с сервера можно с помощью команды:
```
git clone https://github.com/netology-code/sysadm-homeworks.git
```
Репозиторий будет помещен в директорию ./имя_репозитория 

Просмотр удаленных репозиториев:
```
git remote -v - смотрим есть ли хоть что то по удаленным репозиториям
```
В ответ мы увидим имена всех существующих удаленных репозиториев (по умолчанию обычно origin):
```
git remote show origin
```
**Добавление удаленного репозитория**
Подготовка
- Создаем репозиторий с таким именем
- Не ставим галочку README (иначе будет конфликт логов)
- Добавляем публичный ключ в git:
- Token - Settings - SSH and GPG keys - https://github.com/settings/keys
Добавление удаленного репозитория:
```
git remote add origin https://github.com/netology-code/sysadm-homeworks.git
git remote add origin git@github.com:jo-os/git.git (практика)

git push --set-upstream origin main - пушим и создаем нужную ветку main
```
Отправка изменения в удаленный репозиторий:
```
git push origin master
```
Для того чтобы скачать себе последние изменения из репозитория:
```
git pull
```
**.gitignore** - В любой директории внутри репозитория можно создать файл .gitignore В него можно добавить правила игнорирования некоторых файлов. Например, локальный кеш, тестовые конфигурации и прочее.

**Github** — сервис онлайн-хостинга репозиториев, обладающий всеми функциями всего, что поддерживает Git и даже больше. Также GitHub может похвастаться контролем доступа, багтрекингом, управлением задачами и вики для каждого проекта. Кроме GitHub есть другие сервисы, которые используют Git, — например, Bitbucket и GitLab. Вы можете разместить Git-репозиторий на любом из них.

# Что такое DevOps? CI/CD

**DevOps** — это методология разработки ПО, задача которой — наладить взаимодействие программистов и сисадминов в компании. Если ИТ-специалисты из разных отделов недопонимают суть задач друг друга, выпуск новых приложений и обновлений для них затягивается

**CI (Continuous Integration)** — непрерывная интеграция. В задачи этого процесса входит обязанность иметь максимально рабочую версию каждого нового релиза. В первую очередь это сборка и тестирование проекта с каждым внесением изменений

**CD (Continuous Deployment)** — непрерывная поставка. Суть этого процесса заключается в постоянной выкладке ПО, желательно, уже протестированного, на сервера. 

Процессы CI/CD разрабатываются вместе, и в современном мире не принято их делить. Для тестирования проекта вместе с другими его компонентами — база данных, фронтенд и т. п. — необходимо сделать его деплой, а это уже часть процесса CD. Таким образом, для выполнения CI требуется запуск процесса CD, и наоборот, так как перед деплоем проект надо собрать и провести статические тесты

**Пример CI/CD процесса**
- Сборка проекта, например, docker build
-  Запуск статических тестов. В зависимости от языка могут вызываться по-разному и запускаться до сборки
- Деплой проекта на тестовое окружение
- Запуск тестов для всего тестового окружения — интеграционные тесты
- Деплой проекта на продакшн окружение

**Инструменты DevOps** - Для запуска всех описанных процессов обычно используется интеграция с Git. При появлении коммита в Git-сервере запускается процесс CI/CD, который в зависимости от разных параметров коммита — ветка, автор, тег и т. п. — выполняет все действия, необходимые для сборки процесса

Примеры систем, используемых для запуска CI/CD:
- Jenkins
- Gitlab CI
- Teamcity

**Jenkins** — программная система с открытым исходным кодом на Java, предназначенная для обеспечения процесса непрерывной интеграции ПО Jenkins можно установить на Windows, macOS, Debian, Ubuntu, CentOS и другие ОС. Также Jenkins можно установить через системные пакеты, Docker или запустить автономно на любом компьютере с настроенной Java Runtime Environment (JRE) https://www.jenkins.io/

**Установка Jenkins**

Сначала устанавливаем Java:
```
sudo apt install openjdk-11-jdk
```
Затем устанавливаем Jenkins из пакета для debian/ubuntu:
```
sudo wget -O /usr/share/keyrings/jenkins-keyring.asc https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key

echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] https://pkg.jenkins.io/debian-stable binary/ | sudo tee /etc/apt/sources.list.d/jenkins.list > /dev/null

sudo apt-get update
sudo apt-get install jenkins
```
**Первичная настройка**

1. В строке браузера введите IP-адрес сервера и порт 8080 в формате 123.123.123.123:8080
2. На стартовой странице Jenkins указан путь, по которому хранится пароль для входа, обычно:
```
/var/lib/jenkins/secrets/initialAdminPassword
```
3. Введите пароль в браузере для разблокировки Jenkins
4. После предложения установить плагины и создать первого admin пользователя Jenkins доступен для работы

Важно: чтобы получть доступ к Docker из пайплайнов, необходимо добавить пользователя Jenkins в группу Docker и перезапустить Jenkins

**Sonatype Nexus** — интегрированная платформа, с помощью которой разработчики могут хранить и управлять зависимостями Java (Maven), образами Docker, Python, Ruby, NPM, Bower, RPM-пакетами, gitlfs, Apt, Go, Nuget, а также распространять своё ПО. https://help.sonatype.com/repomanager3

Установка с помощью Docker:
```
docker run -d -p 8081:8081 --name nexus -e INSTALL4J_ADD_VM_PARAMS="-Xms2703m -Xmx2703m -XX:MaxDirectMemorySize=273m" sonatype/nexus3
```
Обратите внимание на параметры Xms и Xmx. Это объём выделяемой памяти, по умолчанию равен 2703 Mb

**Nexus: создание helm-репозитория**

1. Переходим на страницу настройки репозиориев:
```
http://123.123.123.123:8081/#admin/repository/repositories
```
2. Создаём новый репозиторий типа helm-hosted
3. Выбираем дополнительные параметры
4. Сохраняем

**Настройка простого pipeline**
- Создаём проект: http://123.123.123.123:8080/view/all/newJob
- Выбираем freestyle project и пишем имя проекта
- Подключаем scm и параметры авторизации, если необходимо
- Переходим в раздел Build, выбираем новый этап сборки типа "Execute shell"
- Пишем любой скрипт, например docker build
- Сохраняем проект и запускаем сборку

**Настройка declarative pipeline**
- Создаём проект: http://123.123.123.123:8080/view/all/newJob
- Выбираем pipeline и пишем имя проекта
- Добавляем скрипт в поле Pipeline
```
pipeline {
  agent any
  stages {
    stage('Git') {
      steps {git 'https://github.com/killmeplz/k8s-job-sidekiller.git'}
    }
    stage('Build') {
      steps {
        sh 'docker build .'
        sh 'helm package .helm'
        sh 'curl -u admin:123 http://10.168.10.220:8081/repository/helm-test/ --upload-file k8s-job-sidekiller-0.1.0.tgz -v'
      }
    }
  }
}
```

# GitLab

**Gitlab** — веб-инструмент жизненного цикла DevOps с открытым исходным кодом, представляющий систему управления репозиториями кода для Git с собственной вики-системой отслеживания ошибок, CI/CD пайплайном и другими функциями. GitLab имеет вариант установки на свои сервера или использование в облаке. Он делится на бесплатную CE версию и EE энтерпрайз.

Функционал Gitlab не заканчивается просто хранением репозиториев. В число инструментов можно включить:
- CI/CD
- Wiki
- Issues
- Snippets
- Pages
- Группы, права доступ

**Gitlab CI**

Настройки CI/CD хранятся вместе с репозиторием в файле .gitlab-ci.yml. После коммита в репозиторий этот файл читается, и запускается пайплайн. Полный синтаксис описан в документации - https://docs.gitlab.com/ee/ci/yaml/ Запуск процессов может выполняться на специальных агентах — раннерах, которые могут быть расположены в облаке Gitlab или на своих серверах

**Gitlab CI: установка раннера**- Раннер может быть расположен на любом сервере, имеющем доступ в интернет (если используется собственный сервер gitlab, то необходимо обеспечить доступ к нему). В настройках проекта или группы необходимо получить токен для регистрации раннера.
```
Set up a specific runner manually
1. Install GitLab Runner and ensure it's running.
2. Register the runner with this URL: https://gitlab.com/
And this registration token: DSC_Zaskdjkhxasdasd
```
После получения токена необходимо установить раннер в любом виде на сервер: https://docs.gitlab.com/runner/install/

Перед запуском раннер необходимо зарегистрировать:
```
docker run -rm -v /srv/gitlab-runner/config:/etc/gitlab-runner -v /var/run/docker.sock:/var/run/docker.sock gitlab/gitlab-runner:latest register
```
После регистрации будет сгенерирован конфиг /etc/gitlab-runner/config.toml и раннер можно запускать:
```
docker run -d --name gitlab-runner --restart always -v /srv/gitlab-runner/config:/etc/gitlab-runner -v /var/run/docker.sock:/var/run/docker.sock gitlab/gitlab-runner:lates
```
**Gitlab CI: настройка раннера**
Раннер может быть запущен в нескольких режимах. Самые популярные: shell и docker. Запуск в режиме shell позволит вам выполнять любые команды просто из shell. В примере выше мы запустили раннер внутри контейнера, предусмотрительно добавив в этот контейнер сокет docker. Теперь мы можем запустить раннер в режиме docker.

**Gitlab CI: пример написания .gitlab-ci.yml**

Stages описывает этапы пайплайна и порядок их запуска. Эти этапы могут не входить в итоговый пайплайн. При описании этапа мы указываем docker image, в котором будем запускать команды из раздела script.
```
stages:
  - build
  - test
test:
  stage: test
  image: golang:latest
  script:
    - echo "Starting tests"
```
**Dind (Docker in docker)** - Для доступа к docker изнутри пайплайна можно применять несколько подходов:

запуск docker демона внутри контейнера:
+ не надо дополнительно настраивать раннеры,
- отсутствие docker кэша, относительно увеличенное время запуска, так как необходимо будет этот демон запустить;

доступ к docker демону хостовой машины:
- требуется дополнительная настройка раннеров,
+ отсутствуют минусы первого подхода

**Настройка раннеров**

Для настройки раннера и проброса докер сокета необходимо добавить в конфигурацию раннера строчку для подключения в контейнеры пайплайна дополнительного volume:
```
[runners.docker]
  volumes = ["/var/run/docker.sock:/var/run/docker.sock"]
```
Также если необходимо дополнительно настроить различные параметры, их полный список можно найти здесь - https://docs.gitlab.com/runner/configuration/advanced-configuration.html

**Настройка пайплайна**

Для начала определимся с этапами, в нашем примере сделаем тестирование, сборку.nКлонируем репозиторий https://github.com/killmeplz/netology-test и перемещаем его на гитлаб:
```
git remote rename origin old-origin
git remote add origin https://gitlab.com/killmeplz685/netology-test.git
git push -u origin --all
git push -u origin --tags
```
Далее начинаем настраивать .gitlab-ci.ymnСоздадим CI согласно тем этапам, которые оговорили.
```
stages:
  - test
  - build
test:
  stage: test
  image: golang:latest
  script:
    - go test .
build:
  stage: build
  image: docker:latest
  script:
    - docker build .
```
Далее сделаем сборку только в мастер ветке, чтобы не собирать каждый коммит и экономить место.
```
stages:
  - test
  - build
test:
  stage: test
  image: golang:latest
  script:
    - go test .
build:
  stage: build
  only:
    - master
  image: docker:latest
  script:
    - docker build .
```
Однако разработчики хотят иметь возможность собирать иногда промежуточные версии для их тестирования вручную. Давайте добавим ручную сборку контейнера для всех веток, кроме мастера.
```
stages:
  - test
  - build
test:
  stage: test
  image: golang:latest
  script:
    - go test .
build_manual:
  stage: build
  except:
    - master
  image: docker:latest
  script:
    - docker build .
build:
  stage: build
  only:
    - master
  image: docker:latest
  script:
    - docker build .
```
**SonarQube** — платформа с открытым исходным кодом для непрерывного анализа и измерения качества программного кода. Поддерживает анализ кода и поиск ошибок согласно правилам стандартов программирования.

**SonarScanner** — компонент, который непосредственно занимается сканированием кода, может быть запущен в качестве контейнера. Давайте добавим его в наш пайплайн.

Добавим проверку sonar-scanner на этап test. Это позволит ему запускаться параллельно с тестами, и не тратить дополнительное время на ожидание.
```
sonarqube-check:
  stage: test
  image:
    name:
sonarsource/sonar-scanner-cli
    entrypoint: [""]
  variables:
  script:
    - sonar-scanner
```
